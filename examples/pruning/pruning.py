"""
Created on Fri May 26 11:01:18 2017
@author: yagweb
""" 
from __future__ import print_function

import os
import copy
import pprint
import warnings

from f90wrap import parser as fparse
from f90wrap import fortran
from f90wrap.sizeof_fortran_t import sizeof_fortran_t
from f90wrap import transform as tf

from f90wrap import f90wrapgen as fwrap
from f90wrap import pywrapgen as pywrap
from f90wrap.pruning import PruningRuleFile, prune
    
def test_parser():
    file = PruningRuleFile('pruning_rules')
    file.dump()
        
def test_generator(files): 
    mod_name = "f90wrap_demo"
    prefix = 'f90wrap_' #Prefix to prepend to arguments and subroutines.
    abort_func = 'f90wrap_abort' #Name of Fortran subroutine to invoke if a fatal error occurs
    package = False #Generate a Python package instead of a single module
    move_methods = False #"Convert routines with derived type instance as first agument into class methods"
    shorten_routine_names = False #"Remove type name prefix from routine names, e.g. cell_symmetrise() -> symmetrise()"
    default_string_length = 1024 #Default length of character strings
    default_to_inout = False #Sets all arguments without intent to intent(inout)
    init_file = None #"Python source file containing code to be added to autogenerated __init__.py"

    # set defaults, to be overriden by command line args and config file
    kind_map = {}
    short_names = {}
    string_lengths = {} #Python dictionary mapping string length names to values
    init_lines = {} #Python dictionary mapping type names to necessary initialisation code
    py_mod_names = {} #Python dictionary mapping Fortran module names to Python ones
    class_names = {} #Python dictionary mapping Fortran type names to Python classes
    argument_name_map = {} #Python dictionary to rename Fortran arguments
    only_subs = [] #Subroutines to include in wrapper
    joint_modules = {}
    callback = []
    remove_optional_arguments = []

    # read command line arguments
    kind_map = eval(open('../arrays/kind_map').read())
    constructors = []
    destructors = []

    print('Kind map (also saved to .f2py_f2cmap)')
    pprint.pprint(kind_map)
    f2py_f2cmap = open('.f2py_f2cmap', 'w')
    pprint.pprint(kind_map, f2py_f2cmap)
    f2py_f2cmap.close()
    print()

    fsize = sizeof_fortran_t()
    print('Size of Fortran derived type pointers is %d bytes.' % fsize)

    # parse input Fortran source files
    print('Parsing Fortran source files %r ...' % files)
    parse_tree = fparse.read_files(files)
    print('done parsing source.')
    print()
    tree = copy.deepcopy(parse_tree)
     
    tree = prune(tree, ['pruning_rules'])
        
    types = fortran.find_types(tree)
    print('Derived types detected in Fortran source files:')
    pprint.pprint(types)
    print()
    
    for type_name, typ in types.items():
        class_names[type_name] = typ.orig_name
    print('Class name mapping:')
    pprint.pprint(class_names)
    
    types = fortran.find_types(tree)
    print('Derived types detected in Fortran source files:')
    pprint.pprint(types)
    print()
        
    # Find all modules and subroutines the user wishes to keep
    kept_subs = []
    kept_mods = set()
    for mod, sub, arg in fortran.walk_procedures(tree):
        if sub.name in only_subs:
            kept_subs.extend([sub])
            if mod is not None:
                kept_mods.add(mod)

    if len(kept_subs) == 0 and only_subs:
        warnings.warn("None of the supplied procedures were found")

    # Find (recursively) all used modules
    kept_mods = tf.find_referenced_modules(kept_mods, tree)

    modules_for_type = {}
    for type_name, typ in types.items():
        modules_for_type[typ.mod_name] = typ.mod_name
    modules_for_type.update(joint_modules)
    print('Modules for each type:')
    pprint.pprint(modules_for_type)
    
    #no type!
    tree = tf.transform_to_generic_wrapper(tree,
                                           types,
                                           callback,
                                           constructors,
                                           destructors,
                                           short_names,
                                           init_lines,
                                           kept_subs,
                                           kept_mods,
                                           argument_name_map,
                                           move_methods,
                                           shorten_routine_names,
                                           modules_for_type,
                                           remove_optional_arguments)
                                           
    
    py_tree = copy.deepcopy(tree)
    f90_tree = copy.deepcopy(tree)

    py_tree = tf.transform_to_py_wrapper(py_tree, types)

    f90_tree = tf.transform_to_f90_wrapper(f90_tree, types,
                                           callback,
                                           constructors,
                                           destructors,
                                           short_names,
                                           init_lines,
                                           string_lengths,
                                           default_string_length,
                                           sizeof_fortran_t=fsize,
                                           kind_map=kind_map)

    pywrap.PythonWrapperGenerator(prefix, mod_name,
                                  types, make_package = package,
                                  kind_map = kind_map,
                                  init_file = init_file,
                                  py_mod_names=py_mod_names,
                                  class_names=class_names).visit(py_tree)
                                  
    fwrap.F90WrapperGenerator(prefix, fsize, string_lengths,
                              abort_func, kind_map, types, default_to_inout).visit(f90_tree)
    
def compile_lib(files):
    obj_files = [os.path.splitext(os.path.basename(bb))[0]+".o" for bb in files]
    f90 = r'"C:\Program Files\mingw-w64\x86_64-7.1.0-posix-seh-rt_v5-rev0\mingw64\bin\gfortran.exe"'
    f90 = r'gfortran'
    for src, obj in zip(files, obj_files): 
        cmd = "%s -m64 -x f95-cpp-input -fPIC -c %s -o %s" % (f90, src, obj)
        print(cmd)
        os.system(cmd)
    cmd = "ar -rcs libsrc.a %s" % (" ".join(obj_files))
    print(cmd)
    os.system(cmd)
        
def compile_ext():
    import glob
    import platform
    sysstr = platform.system()
    if(sysstr == "Windows"):
        files = glob.glob('f90wrap_*.f90')#windows cmd not support wildcard
        cc = '--compiler=mingw32'
    else:
        files = 'f90wrap_*.f90'
        cc = ''
    mod_name = "demo"
    f2py = os.path.abspath("../../scripts/f2py-f90wrap")
    # --compiler=mingw32  #symbol table not found
    cmd = "python {f2py} {cc} --fcompiler=gfortran --verbose ".format(f2py = f2py, cc = cc) + \
    "--build-dir . -c -m {mod_name} -L. -lsrc {files}".format(mod_name = mod_name, files = " ".join(files))
    print(cmd)
    os.system(cmd)
    
if __name__ == "__main__":
#    test_parser()
    files = [
             '../arrayderivedtypes/test.f90',
             '../arrays/parameters.f90',
             '../arrays/library.f90',
            ]
#    compile_lib(files)
#    test_generator(files)
    compile_ext()